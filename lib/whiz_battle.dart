import 'package:flutter/material.dart';import 'dart:async';import 'dart:math';import 'package:flutter/services.dart';import 'quiz_questions.dart';import 'services/battle_websocket_service.dart';import 'quiz_api.dart';import 'global_music_manager.dart';import 'package:flame_audio/flame_audio.dart';// ============================================================================// DATA MODELS// ============================================================================class BattleRoom {  final String gameCode;  final String category;  final String difficulty;  BattleRoom({    required this.gameCode,    required this.category,    required this.difficulty,  });}// ============================================================================// MAIN BATTLE SCREEN (Room Creation/Join)// ============================================================================class WhizBattle extends StatefulWidget {  final String userAvatar;  final String userId;  final String username;  const WhizBattle({    super.key,    required this.userAvatar,    required this.userId,    required this.username,  });  @override  State<WhizBattle> createState() => _WhizBattleState();}class _WhizBattleState extends State<WhizBattle> {  final TextEditingController _roomCodeController = TextEditingController();  String _selectedCategory = "Science";  String _selectedDifficulty = "Easy";  bool _isLoading = false;  @override  void dispose() {    _roomCodeController.dispose();    super.dispose();  }  String _generateRoomCode() {    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';    return List.generate(6, (index) => chars[Random().nextInt(chars.length)]).join();  }  Future<void> _createRoom() async {    if (_isLoading) return;    try {      await FlameAudio.play('click1.wav');    } catch (e) {      debugPrint('Click sound not found: $e');    }    setState(() => _isLoading = true);    final roomCode = _generateRoomCode();    final wsService = BattleWebSocketService();    final connected = await wsService.connect(widget.userId);    if (!connected) {      if (mounted) {        ScaffoldMessenger.of(context).showSnackBar(          const SnackBar(content: Text('‚ùå Failed to connect to server')),        );        setState(() => _isLoading = false);      }      return;    }    debugPrint('üîó WebSocket connected, instance: ${wsService.hashCode}');    wsService.createRoom(      roomCode: roomCode,      hostName: widget.username,      hostAvatar: widget.userAvatar,      category: _selectedCategory,      difficulty: _selectedDifficulty,    );    await Future.delayed(const Duration(milliseconds: 500));    if (mounted) {      setState(() => _isLoading = false);      debugPrint('üì± Navigating to BattleGameScreen with WS instance: ${wsService.hashCode}');      Navigator.push(        context,        MaterialPageRoute(          builder: (context) => BattleGameScreen(            battleRoom: BattleRoom(              gameCode: roomCode,              category: _selectedCategory,              difficulty: _selectedDifficulty,            ),            userId: widget.userId,            username: widget.username,            userAvatar: widget.userAvatar,            isHost: true,            webSocketService: wsService,          ),        ),      );    }  }  Future<void> _joinRoom() async {    final roomCode = _roomCodeController.text.trim().toUpperCase();    if (roomCode.isEmpty) {      ScaffoldMessenger.of(context).showSnackBar(        const SnackBar(content: Text('Please enter a room code')),      );      return;    }    try {      await FlameAudio.play('click1.wav');    } catch (e) {      debugPrint('Click sound not found: $e');    }    setState(() => _isLoading = true);    final wsService = BattleWebSocketService();    final connected = await wsService.connect(widget.userId);    if (!connected) {      if (mounted) {        ScaffoldMessenger.of(context).showSnackBar(          const SnackBar(content: Text('Failed to connect to server')),        );        setState(() => _isLoading = false);      }      return;    }    String? hostName;    String? hostAvatar;    String? errorMessage;    final subscription = wsService.messages.listen((message) {      final event = message['event'];      if (event == 'join_success') {        hostName = message['host_name'];        hostAvatar = message['host_avatar'];      } else if (event == 'error') {        errorMessage = message['message'];      }    });    wsService.joinRoom(      roomCode: roomCode,      playerName: widget.username,      playerAvatar: widget.userAvatar,    );    for (int i = 0; i < 50; i++) {      await Future.delayed(const Duration(milliseconds: 100));      if (hostName != null || errorMessage != null) break;    }    subscription.cancel();    if (errorMessage != null) {      if (mounted) {        wsService.disconnect();        ScaffoldMessenger.of(context).showSnackBar(          SnackBar(            content: Text('‚ùå $errorMessage'),            backgroundColor: Colors.red,            duration: const Duration(seconds: 3),          ),        );        setState(() => _isLoading = false);      }      return;    }    if (hostName == null) {      if (mounted) {        wsService.disconnect();        ScaffoldMessenger.of(context).showSnackBar(          const SnackBar(            content: Text('‚ùå Invalid code. Please check and try again.'),            backgroundColor: Colors.red,            duration: Duration(seconds: 3),          ),        );        setState(() => _isLoading = false);      }      return;    }    if (mounted) {      setState(() => _isLoading = false);      Navigator.push(        context,        MaterialPageRoute(          builder: (context) => BattleGameScreen(            battleRoom: BattleRoom(              gameCode: roomCode,              category: _selectedCategory,              difficulty: _selectedDifficulty,            ),            userId: widget.userId,            username: widget.username,            userAvatar: widget.userAvatar,            isHost: false,            webSocketService: wsService,            initialOpponentName: hostName,            initialOpponentAvatar: hostAvatar,          ),        ),      );    }  }  @override  Widget build(BuildContext context) {    return Scaffold(      backgroundColor: Colors.white,      body: Column(        children: [          _buildTopBar(),          Expanded(child: _buildSelectionScreen()),        ],      ),    );  }  Widget _buildTopBar() {    return Column(      mainAxisSize: MainAxisSize.min,      children: [        Container(          color: Colors.white,          padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 4),          child: Row(            children: [              Image.asset(                "assets/images-logo/starbooksmainlogo.png",                width: 150,                height: 50,                fit: BoxFit.contain,              ),              const Spacer(),              Container(                width: 44,                height: 44,                decoration: BoxDecoration(                  shape: BoxShape.circle,                  border: Border.all(color: const Color(0xFFC571E2), width: 3),                ),                child: ClipOval(                  child: Image.asset(                    widget.userAvatar,                    fit: BoxFit.cover,                  ),                ),              ),            ],          ),        ),        Container(          width: double.infinity,          padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 14),          decoration: const BoxDecoration(            color: Color(0xFFC571E2),            boxShadow: [BoxShadow(color: Colors.black12, blurRadius: 3, offset: Offset(0, 2))],          ),          child: Row(            children: [              IconButton(                icon: const Icon(Icons.arrow_back, color: Colors.white, size: 28),                onPressed: () async {                  try {                    await FlameAudio.play('click1.wav');                  } catch (e) {                    debugPrint('Click sound not found: $e');                  }                  Navigator.pop(context);                },                padding: EdgeInsets.zero,                constraints: const BoxConstraints(),              ),              Expanded(                child: Text(                  "Starbooks Whiz Battle",                  textAlign: TextAlign.center,                  style: const TextStyle(                    color: Colors.white,                    fontSize: 17,                    fontWeight: FontWeight.bold,                    fontFamily: 'Poppins',                  ),                ),              ),              const SizedBox(width: 28),            ],          ),        ),      ],    );  }  Widget _buildSelectionScreen() {    return Center(      child: SingleChildScrollView(        child: Padding(          padding: const EdgeInsets.all(40),          child: Column(            mainAxisAlignment: MainAxisAlignment.center,            children: [              Row(                mainAxisAlignment: MainAxisAlignment.center,                crossAxisAlignment: CrossAxisAlignment.start,                children: [                  Column(                    children: [                      const Text(                        "Select Category",                        style: TextStyle(                          fontSize: 28,                          fontWeight: FontWeight.bold,                          color: Color(0xFFC571E2),                          fontFamily: 'Poppins',                        ),                      ),                      const SizedBox(height: 30),                      Row(                        children: [                          _buildCategoryCard('Science', 'assets/images-icons/science.png'),                          const SizedBox(width: 30),                          _buildCategoryCard('Math', 'assets/images-icons/math.png'),                        ],                      ),                    ],                  ),                  const SizedBox(width: 80),                  Column(                    children: [                      const Text(                        "Difficulty Level",                        style: TextStyle(                          fontSize: 28,                          fontWeight: FontWeight.bold,                          color: Color(0xFFC571E2),                          fontFamily: 'Poppins',                        ),                      ),                      const SizedBox(height: 30),                      _buildDifficultyButton('Easy', const Color(0xFF1D9358)),                      _buildDifficultyButton('Average', const Color(0xFF046EB8)),                      _buildDifficultyButton('Difficult', const Color(0xFFBD442E)),                    ],                  ),                ],              ),              const SizedBox(height: 50),              ElevatedButton(                onPressed: _isLoading ? null : _createRoom,                style: ElevatedButton.styleFrom(                  backgroundColor: const Color(0xFFC571E2),                  foregroundColor: Colors.white,                  padding: const EdgeInsets.symmetric(horizontal: 44, vertical: 14),                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(30)),                ),                child: _isLoading                    ? const SizedBox(                  width: 20,                  height: 20,                  child: CircularProgressIndicator(color: Colors.white, strokeWidth: 2),                )                    : const Text(                  "CREATE ROOM",                  style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold, fontFamily: 'Poppins'),                ),              ),              const SizedBox(height: 30),              const Row(                children: [                  Expanded(child: Divider(thickness: 1)),                  Padding(                    padding: EdgeInsets.symmetric(horizontal: 20),                    child: Text('OR', style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold, color: Colors.grey, fontFamily: 'Poppins')),                  ),                  Expanded(child: Divider(thickness: 1)),                ],              ),              const SizedBox(height: 30),              Container(                constraints: const BoxConstraints(maxWidth: 400),                child: Column(                  children: [                    TextField(                      controller: _roomCodeController,                      decoration: InputDecoration(                        labelText: 'Enter Room Code',                        hintText: 'ABC123',                        border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),                      ),                      textCapitalization: TextCapitalization.characters,                      maxLength: 6,                      textAlign: TextAlign.center,                      style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold, letterSpacing: 2),                    ),                    const SizedBox(height: 15),                    SizedBox(                      width: double.infinity,                      child: ElevatedButton(                        onPressed: _isLoading ? null : _joinRoom,                        style: ElevatedButton.styleFrom(                          backgroundColor: Colors.white,                          foregroundColor: const Color(0xFFC571E2),                          side: const BorderSide(color: Color(0xFFC571E2), width: 2),                          padding: const EdgeInsets.symmetric(vertical: 14),                          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(30)),                        ),                        child: const Text(                          "JOIN ROOM",                          style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold, fontFamily: 'Poppins'),                        ),                      ),                    ),                  ],                ),              ),            ],          ),        ),      ),    );  }  Widget _buildCategoryCard(String category, String imagePath) {    final isSelected = _selectedCategory == category;    return GestureDetector(      onTap: () async {        try {          await FlameAudio.play('click1.wav');        } catch (e) {          debugPrint('Click sound not found: $e');        }        setState(() => _selectedCategory = category);      },      child: Container(        width: 220,        height: 280,        decoration: BoxDecoration(          color: Colors.white,          borderRadius: BorderRadius.circular(16),          border: Border.all(            color: isSelected ? const Color(0xFFC571E2) : Colors.grey.shade300,            width: isSelected ? 4 : 2,          ),        ),        child: Column(          children: [            Expanded(              child: Image.asset(imagePath, fit: BoxFit.cover),            ),            Container(              padding: const EdgeInsets.symmetric(vertical: 18),              child: Text(                category,                style: TextStyle(                  fontSize: 22,                  fontWeight: FontWeight.bold,                  color: isSelected ? Colors.black : Colors.grey[700],                  fontFamily: 'Poppins',                ),              ),            ),          ],        ),      ),    );  }  Widget _buildDifficultyButton(String difficulty, Color color) {    final isSelected = _selectedDifficulty == difficulty;    return GestureDetector(      onTap: () async {        try {          await FlameAudio.play('click1.wav');        } catch (e) {          debugPrint('Click sound not found: $e');        }        setState(() => _selectedDifficulty = difficulty);      },      child: Container(        width: 280,        padding: const EdgeInsets.symmetric(vertical: 16),        margin: const EdgeInsets.only(bottom: 16),        decoration: BoxDecoration(          color: isSelected ? color : Colors.white,          borderRadius: BorderRadius.circular(30),          border: Border.all(color: color, width: 3),        ),        child: Text(          difficulty.toUpperCase(),          textAlign: TextAlign.center,          style: TextStyle(            fontSize: 18,            fontWeight: FontWeight.bold,            color: isSelected ? Colors.white : color,            fontFamily: 'Poppins',          ),        ),      ),    );  }}// ============================================================================// BATTLE GAME SCREEN// ============================================================================class BattleGameScreen extends StatefulWidget {  final BattleRoom battleRoom;  final String userId;  final String username;  final String userAvatar;  final bool isHost;  final BattleWebSocketService webSocketService;  final String? initialOpponentName;  final String? initialOpponentAvatar;  const BattleGameScreen({    super.key,    required this.battleRoom,    required this.userId,    required this.username,    required this.userAvatar,    required this.isHost,    required this.webSocketService,    this.initialOpponentName,    this.initialOpponentAvatar,  });  @override  State<BattleGameScreen> createState() => _BattleGameScreenState();}class _BattleGameScreenState extends State<BattleGameScreen> {  String get baseUrl => "http://localhost/api";  List<Question> questions = [];  int currentQuestionIndex = 0;  int myScore = 0;  int opponentScore = 0;  bool gameStarted = false;  int correctAnswersCount = 0;  Map<String, dynamic>? badgeAwarded;  String opponentName = "Waiting...";  String opponentAvatar = "assets/images-avatars/default.png";  bool opponentJoined = false;  Timer? questionTimer;  int timeRemaining = 15;  bool showFeedback = false;  bool wasCorrect = false;  int earnedPoints = 0;  bool waitingForOpponent = false;  late StreamSubscription wsSubscription;  @override  void initState() {    super.initState();    if (widget.initialOpponentName != null) {      opponentName = widget.initialOpponentName!;      opponentAvatar = widget.initialOpponentAvatar ?? "assets/images-avatars/default.png";      opponentJoined = true;      debugPrint('üéØ Initialized with opponent: $opponentName');    }    _listenToWebSocket();  }  @override  void dispose() {    questionTimer?.cancel();    wsSubscription.cancel();    super.dispose();  }  void _listenToWebSocket() {    debugPrint('üéß Starting to listen to WebSocket messages...');    wsSubscription = widget.webSocketService.messages.listen((message) {      if (!mounted) {        debugPrint('‚ö†Ô∏è Received message but widget not mounted');        return;      }      final event = message['event'];      debugPrint('‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');      debugPrint('üì® Event received: $event');      debugPrint('üì® Full message: $message');      debugPrint('üì® isHost: ${widget.isHost}');      debugPrint('üì® Current opponentName: $opponentName');      debugPrint('üì® Current opponentJoined: $opponentJoined');      debugPrint('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');      switch (event) {        case 'room_created':          debugPrint('‚úÖ Room created successfully');          break;        case 'opponent_joined':          debugPrint('üë• *** OPPONENT_JOINED EVENT PROCESSING ***');          debugPrint('   Received opponent_name: ${message['opponent_name']}');          debugPrint('   Received opponent_avatar: ${message['opponent_avatar']}');          if (mounted) {            setState(() {              opponentName = message['opponent_name'] ?? 'Opponent';              opponentAvatar = message['opponent_avatar'] ?? 'assets/images-avatars/default.png';              opponentJoined = true;            });            debugPrint('‚úÖ State updated!');            debugPrint('   NEW opponentName: $opponentName');            debugPrint('   NEW opponentAvatar: $opponentAvatar');            debugPrint('   NEW opponentJoined: $opponentJoined');          } else {            debugPrint('‚ö†Ô∏è Widget not mounted, cannot update state');          }          break;        case 'join_success':          debugPrint('‚úÖ Join success event received');          debugPrint('   Host Name: ${message['host_name']}');          debugPrint('   Host Avatar: ${message['host_avatar']}');          if (mounted) {            setState(() {              opponentName = message['host_name'] ?? 'Host';              opponentAvatar = message['host_avatar'] ?? 'assets/images-avatars/default.png';              opponentJoined = true;            });            debugPrint('‚úÖ State updated for joiner - opponentName: $opponentName');          }          break;        case 'game_started':          debugPrint('üéÆ game_started event received');          debugPrint('   Current opponentName before game start: $opponentName');          debugPrint('   Current opponentJoined before game start: $opponentJoined');          _handleGameStarted(message);          break;        case 'score_update':          _handleScoreUpdate(message);          break;        case 'both_answered':          _handleBothAnswered(message);          break;        case 'next_question':          _nextQuestion();          break;        case 'game_over':          _handleGameOver(message);          break;        case 'player_left':        case 'player_disconnected':          debugPrint('‚ùå Opponent left or disconnected');          final wonByForfeit = message['won_by_forfeit'] ?? false;          if (wonByForfeit) {            _showOpponentLeftDialog();          } else {            _showOpponentLeftDialog();          }          break;        case 'error':          ScaffoldMessenger.of(context).showSnackBar(            SnackBar(content: Text(message['message'] ?? 'Error occurred')),          );          break;      }    });  }  void _handleGameStarted(Map<String, dynamic> message) {    GlobalMusicManager().stopMusic();    final questionsData = message['questions'] as List<dynamic>?;    if (questionsData == null) {      debugPrint('‚ùå No questions received');      return;    }    debugPrint('üéÆ Game starting...');    debugPrint('   My name: ${widget.username}');    debugPrint('   Opponent name: $opponentName');    debugPrint('   Opponent joined: $opponentJoined');    questions = questionsData.map((q) {      final qMap = q as Map<String, dynamic>;      return Question(        question: qMap['question'] ?? '',        options: [          qMap['choice_a'] ?? '',          qMap['choice_b'] ?? '',          qMap['choice_c'] ?? '',          qMap['choice_d'] ?? '',        ],        correctAnswer: qMap['correct_answer'] ?? '',      );    }).toList();    setState(() {      gameStarted = true;      currentQuestionIndex = 0;      correctAnswersCount = 0;    });    _startQuestionTimer();    debugPrint('üéÆ Game started with ${questions.length} questions');  }  void _handleScoreUpdate(Map<String, dynamic> message) {    // Score updates are handled in both_answered  }  void _handleBothAnswered(Map<String, dynamic> message) {    final scores = message['scores'] as Map<String, dynamic>?;    if (scores != null) {      setState(() {        myScore = (scores[widget.userId] as num?)?.toInt() ?? myScore;        scores.forEach((key, value) {          if (key != widget.userId) {            opponentScore = (value as num?)?.toInt() ?? opponentScore;          }        });        waitingForOpponent = false;      });    }  }  void _handleGameOver(Map<String, dynamic> message) async {    final winnerId = message['winner_id'] as String?;    final didIWin = winnerId == widget.userId;    try {      final response = await QuizApiService.saveBattleResult(        playerId: widget.userId,        category: widget.battleRoom.category,        difficulty: widget.battleRoom.difficulty,        score: myScore,        result: didIWin ? 'won' : 'lost',        questionsAnswered: questions.length,        correctAnswers: correctAnswersCount,        battleId: widget.battleRoom.gameCode,      );      if (response != null && response['badge_awarded'] != null) {        badgeAwarded = response['badge_awarded'];        debugPrint('üéØ Badge info received: $badgeAwarded');      }    } catch (e) {      debugPrint('Error saving: $e');    }    if (!mounted) return;    Navigator.of(context).pushReplacement(      MaterialPageRoute(        builder: (context) => BattleResultScreen(          category: widget.battleRoom.category,          difficulty: widget.battleRoom.difficulty,          gameCode: widget.battleRoom.gameCode,          myScore: myScore,          opponentScore: opponentScore,          myName: widget.username,          opponentName: opponentName,          myAvatar: widget.userAvatar,          opponentAvatar: opponentAvatar,          totalQuestions: questions.length,          didIWin: didIWin,          badgeAwarded: badgeAwarded,        ),      ),    );  }  void _startQuestionTimer() {    timeRemaining = 15;    questionTimer?.cancel();    questionTimer = Timer.periodic(const Duration(seconds: 1), (timer) {      if (!mounted) {        timer.cancel();        return;      }      setState(() {        if (timeRemaining > 0) {          timeRemaining--;        } else {          timer.cancel();          if (!showFeedback) {            _handleAnswer('');          }        }      });    });  }  void _handleAnswer(String answer) {    if (showFeedback) return;    questionTimer?.cancel();    final isCorrect = answer == questions[currentQuestionIndex].correctAnswer;    final points = isCorrect ? timeRemaining : 0;    setState(() {      showFeedback = true;      wasCorrect = isCorrect;      earnedPoints = points;      myScore += points;      waitingForOpponent = true;      if (isCorrect) {        correctAnswersCount++;      }    });    widget.webSocketService.submitAnswer(      roomCode: widget.battleRoom.gameCode,      isCorrect: isCorrect,      points: points,      questionIndex: currentQuestionIndex,    );    debugPrint('üìù Answer: ${isCorrect ? "‚úÖ" : "‚ùå"} (+$points pts)');    debugPrint('üìä Correct answers so far: $correctAnswersCount/${currentQuestionIndex + 1}');  }  void _nextQuestion() {    setState(() {      currentQuestionIndex++;      showFeedback = false;      wasCorrect = false;      earnedPoints = 0;      waitingForOpponent = false;    });    _startQuestionTimer();  }  void _showOpponentLeftDialog() {    questionTimer?.cancel();    if (!mounted) return;    final didIWinByForfeit = gameStarted;    showDialog(      context: context,      barrierDismissible: false,      builder: (context) => AlertDialog(        title: Row(          children: [            Icon(              didIWinByForfeit ? Icons.emoji_events : Icons.warning_amber_rounded,              color: didIWinByForfeit ? Colors.amber : Colors.orange,              size: 32,            ),            const SizedBox(width: 12),            Text(didIWinByForfeit ? 'Victory!' : 'Battle Ended'),          ],        ),        content: Column(          mainAxisSize: MainAxisSize.min,          children: [            Text(              didIWinByForfeit                  ? 'Your opponent has left. You win by forfeit!'                  : 'Your opponent has left the battle.',              style: const TextStyle(fontSize: 16),            ),            const SizedBox(height: 16),            if (!didIWinByForfeit)              const Text(                'The room has been closed.',                style: TextStyle(fontSize: 14, color: Colors.grey),              ),          ],        ),        actions: [          ElevatedButton(            onPressed: () async {              try {                await FlameAudio.play('click1.wav');              } catch (e) {                debugPrint('Click sound not found: $e');              }              widget.webSocketService.disconnect();              Navigator.of(context).pop();              Navigator.of(context).pop();            },            style: ElevatedButton.styleFrom(              backgroundColor: const Color(0xFFC571E2),              padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),            ),            child: const Text('OK', style: TextStyle(color: Colors.white)),          ),        ],      ),    );  }  Color _getDifficultyColor() {    switch (widget.battleRoom.difficulty.toUpperCase()) {      case "EASY":        return const Color(0xFF1D9358);      case "AVERAGE":        return const Color(0xFF046EB8);      case "DIFFICULT":        return const Color(0xFFBD442E);      default:        return const Color(0xFF1D9358);    }  }  @override  Widget build(BuildContext context) {    final color = _getDifficultyColor();    if (widget.isHost && !opponentJoined) {      return PopScope(          canPop: true,        onPopInvokedWithResult: (didPop, result) {          if (didPop) {            widget.webSocketService.leaveRoom(widget.battleRoom.gameCode);            widget.webSocketService.disconnect();          }        },        child: Scaffold(          body: Center(            child: Column(              mainAxisAlignment: MainAxisAlignment.center,              children: [                const CircularProgressIndicator(),                const SizedBox(height: 20),                const Text('Waiting for opponent...', style: TextStyle(fontSize: 18, fontFamily: 'Poppins')),                const SizedBox(height: 20),                // In WhizBattle.dart, around line 470 in the waiting room UI                Container(                  padding: const EdgeInsets.all(20),                  decoration: BoxDecoration(                    color: color,                    borderRadius: BorderRadius.circular(12),                  ),                  child: Column(                    children: [                      const Text('Room Code:', style: TextStyle(color: Colors.white)),                      const SizedBox(height: 8),                      Row(                        mainAxisSize: MainAxisSize.min,                        children: [                          Text(                            widget.battleRoom.gameCode,                            style: const TextStyle(                              fontSize: 32,                              fontWeight: FontWeight.bold,                              color: Colors.white,                              letterSpacing: 4,                            ),                          ),                          const SizedBox(width: 12),                          // ‚úÖ ADD THIS COPY BUTTON                          IconButton(                            onPressed: () {                              Clipboard.setData(                                ClipboardData(text: widget.battleRoom.gameCode),                              );                              ScaffoldMessenger.of(context).showSnackBar(                                const SnackBar(                                  content: Text('Room code copied!'),                                  duration: Duration(seconds: 2),                                ),                              );                            },                            icon: const Icon(Icons.copy, color: Colors.white),                            tooltip: 'Copy Code',                          ),                        ],                      ),                    ],                  ),                ),                const SizedBox(height: 30),                OutlinedButton.icon(                  onPressed: () async {                    try {                      await FlameAudio.play('click1.wav');                    } catch (e) {                      debugPrint('Click sound not found: $e');                    }                    widget.webSocketService.leaveRoom(widget.battleRoom.gameCode);                    widget.webSocketService.disconnect();                    Navigator.of(context).pop();                  },                  icon: const Icon(Icons.close),                  label: const Text('Cancel'),                  style: OutlinedButton.styleFrom(                    foregroundColor: Colors.red,                    side: const BorderSide(color: Colors.red),                    padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),                  ),                ),              ],            ),          ),        ),      );    }    // HOST: Opponent joined, show START button    if (widget.isHost && opponentJoined && !gameStarted) {      return PopScope(        canPop: true,        onPopInvokedWithResult: (didPop, result) {          if (didPop) {            widget.webSocketService.leaveRoom(widget.battleRoom.gameCode);            widget.webSocketService.disconnect();          }        },        child: Scaffold(          body: Center(            child: Column(              mainAxisAlignment: MainAxisAlignment.center,              children: [                const Icon(Icons.check_circle, color: Color(0xFF1D9358), size: 80),                const SizedBox(height: 20),                const Text('Opponent Ready!', style: TextStyle(fontSize: 28, fontWeight: FontWeight.bold, fontFamily: 'Poppins')),                const SizedBox(height: 20),                Text(opponentName, style: const TextStyle(fontSize: 20, fontFamily: 'Poppins')),                const SizedBox(height: 40),                ElevatedButton(                  onPressed: () async {                    try {                      await FlameAudio.play('click1.wav');                    } catch (e) {                      debugPrint('Click sound not found: $e');                    }                    widget.webSocketService.startGame(widget.battleRoom.gameCode);                  },                  style: ElevatedButton.styleFrom(                    backgroundColor: color,                    padding: const EdgeInsets.symmetric(horizontal: 60, vertical: 20),                    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(30)),                  ),                  child: const Text(                    'START BATTLE',                    style: TextStyle(fontSize: 22, fontWeight: FontWeight.bold, fontFamily: 'Poppins', color: Colors.white),                  ),                ),              ],            ),          ),        ),      );    }    // JOINER: Waiting for host to start    if (!widget.isHost && !gameStarted) {      return PopScope(        canPop: true,        onPopInvokedWithResult: (didPop, result) {          if (didPop) {            widget.webSocketService.leaveRoom(widget.battleRoom.gameCode);            widget.webSocketService.disconnect();          }        },        child: Scaffold(          body: Center(            child: Column(              mainAxisAlignment: MainAxisAlignment.center,              children: [                const CircularProgressIndicator(),                const SizedBox(height: 20),                const Text('Waiting for host to start...', style: TextStyle(fontSize: 18, fontFamily: 'Poppins')),                if (opponentJoined) ...[                  const SizedBox(height: 20),                  Text('Host: $opponentName', style: const TextStyle(fontSize: 16, fontFamily: 'Poppins')),                ],                const SizedBox(height: 30),                OutlinedButton.icon(                  onPressed: () async {                    try {                      await FlameAudio.play('click1.wav');                    } catch (e) {                      debugPrint('Click sound not found: $e');                    }                    widget.webSocketService.leaveRoom(widget.battleRoom.gameCode);                    widget.webSocketService.disconnect();                    Navigator.of(context).pop();                  },                  icon: const Icon(Icons.close),                  label: const Text('Leave'),                  style: OutlinedButton.styleFrom(                    foregroundColor: Colors.red,                    side: const BorderSide(color: Colors.red),                    padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),                  ),                ),              ],            ),          ),        ),      );    }    // GAME STARTED    if (gameStarted && questions.isNotEmpty) {      final question = questions[currentQuestionIndex];      return PopScope(        canPop: false,        onPopInvokedWithResult: (didPop, result) async {          if (!didPop) {            // Show confirmation dialog before leaving during game            final shouldLeave = await showDialog<bool>(              context: context,              builder: (ctx) => AlertDialog(                title: const Text('Leave Battle?'),                content: const Text('Are you sure you want to leave? This will end the battle.'),                actions: [                  TextButton(                    onPressed: () => Navigator.of(ctx).pop(false),                    child: const Text('Cancel'),                  ),                  ElevatedButton(                    onPressed: () => Navigator.of(ctx).pop(true),                    style: ElevatedButton.styleFrom(backgroundColor: Colors.red),                    child: const Text('Leave', style: TextStyle(color: Colors.white)),                  ),                ],              ),            );            if (shouldLeave == true && context.mounted) {              widget.webSocketService.leaveRoom(widget.battleRoom.gameCode);              widget.webSocketService.disconnect();              Navigator.of(context).pop();            }          }        },        child: Scaffold(          body: Column(            children: [              // Header              Container(                color: color,                padding: const EdgeInsets.all(16),                child: Row(                  mainAxisAlignment: MainAxisAlignment.spaceBetween,                  children: [                    Text(                      '${widget.battleRoom.category} - ${widget.battleRoom.difficulty}',                      style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold, fontFamily: 'Poppins'),                    ),                    Text(                      'Room: ${widget.battleRoom.gameCode}',                      style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold, fontFamily: 'Poppins'),                    ),                  ],                ),              ),              Expanded(                child: showFeedback ? _buildFeedback() : _buildQuestion(question),              ),            ],          ),        ),      );    }    // Loading    return const Scaffold(      body: Center(child: CircularProgressIndicator()),    );  }  Widget _buildQuestion(Question question) {    return Center(      child: SingleChildScrollView(        child: Padding(          padding: const EdgeInsets.all(20),          child: Column(            children: [              // Scoreboard              Row(                mainAxisAlignment: MainAxisAlignment.spaceEvenly,                children: [                  _buildPlayerCard(widget.username, widget.userAvatar, myScore),                  const Text('VS', style: TextStyle(fontSize: 32, fontWeight: FontWeight.bold)),                  _buildPlayerCard(opponentName, opponentAvatar, opponentScore),                ],              ),              const SizedBox(height: 20),              // Timer              Container(                padding: const EdgeInsets.all(16),                decoration: BoxDecoration(                  color: timeRemaining <= 5 ? Colors.red.shade100 : Colors.grey.shade200,                  borderRadius: BorderRadius.circular(12),                ),                child: Row(                  mainAxisAlignment: MainAxisAlignment.center,                  children: [                    Icon(Icons.timer, color: timeRemaining <= 5 ? Colors.red : Colors.blue),                    const SizedBox(width: 10),                    Text(                      '$timeRemaining seconds',                      style: TextStyle(                        fontSize: 24,                        fontWeight: FontWeight.bold,                        color: timeRemaining <= 5 ? Colors.red : Colors.black,                      ),                    ),                  ],                ),              ),              const SizedBox(height: 20),              // Question number              Text(                'Question ${currentQuestionIndex + 1} of ${questions.length}',                style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold),              ),              const SizedBox(height: 20),              // Question text              Container(                padding: const EdgeInsets.all(20),                decoration: BoxDecoration(                  color: Colors.grey.shade100,                  borderRadius: BorderRadius.circular(12),                  border: Border.all(color: Colors.blue, width: 2),                ),                child: Text(                  question.question,                  style: const TextStyle(fontSize: 18, fontWeight: FontWeight.w500),                  textAlign: TextAlign.center,                ),              ),              const SizedBox(height: 20),              // Answer options              ...question.options.map((option) => _buildAnswerButton(option)),            ],          ),        ),      ),    );  }  Widget _buildAnswerButton(String answer) {    return Container(      width: double.infinity,      margin: const EdgeInsets.only(bottom: 10),      child: ElevatedButton(        onPressed: () => _handleAnswer(answer),        style: ElevatedButton.styleFrom(          padding: const EdgeInsets.all(16),          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),        ),        child: Text(answer, style: const TextStyle(fontSize: 16)),      ),    );  }  Widget _buildFeedback() {    return Center(      child: Padding(        padding: const EdgeInsets.all(20),        child: Column(          mainAxisAlignment: MainAxisAlignment.center,          children: [            // Scoreboard            Row(              mainAxisAlignment: MainAxisAlignment.spaceEvenly,              children: [                _buildPlayerCard(widget.username, widget.userAvatar, myScore),                const Text('VS', style: TextStyle(fontSize: 32, fontWeight: FontWeight.bold)),                _buildPlayerCard(opponentName, opponentAvatar, opponentScore),              ],            ),            const SizedBox(height: 40),            // Result            Text(              wasCorrect ? 'CORRECT!' : 'WRONG!',              style: TextStyle(                fontSize: 50,                fontWeight: FontWeight.bold,                color: wasCorrect ? const Color(0xFF1D9358) : const Color(0xFFE74C3C),              ),            ),            const SizedBox(height: 20),            // Points earned            if (wasCorrect)              Container(                padding: const EdgeInsets.all(16),                decoration: BoxDecoration(                  color: const Color(0xFF1D9358).withValues(alpha: 0.1),                  borderRadius: BorderRadius.circular(12),                  border: Border.all(color: const Color(0xFF1D9358), width: 2),                ),                child: Text(                  '+$earnedPoints points',                  style: const TextStyle(                    fontSize: 28,                    fontWeight: FontWeight.bold,                    color: Color(0xFF1D9358),                  ),                ),              ),            const SizedBox(height: 20),            // Correct answer            Text(              'Correct Answer: ${questions[currentQuestionIndex].correctAnswer}',              style: const TextStyle(fontSize: 20, fontWeight: FontWeight.w600),              textAlign: TextAlign.center,            ),            // Waiting indicator            if (waitingForOpponent) ...[              const SizedBox(height: 30),              const CircularProgressIndicator(),              const SizedBox(height: 15),              const Text(                'Waiting for opponent...',                style: TextStyle(fontSize: 18, color: Colors.grey),              ),            ],          ],        ),      ),    );  }  Widget _buildPlayerCard(String name, String avatar, int score) {    return Container(      padding: const EdgeInsets.all(16),      decoration: BoxDecoration(        color: Colors.white,        borderRadius: BorderRadius.circular(16),        border: Border.all(color: Colors.blue, width: 3),        boxShadow: const [BoxShadow(color: Colors.black12, blurRadius: 8)],      ),      child: Column(        children: [          CircleAvatar(            radius: 30,            backgroundImage: AssetImage(avatar),            onBackgroundImageError: (exception, stackTrace) {              debugPrint('Failed to load avatar: $avatar');            },          ),          const SizedBox(height: 8),          Text(name, style: const TextStyle(fontSize: 14, fontWeight: FontWeight.bold)),          const SizedBox(height: 4),          Row(            mainAxisSize: MainAxisSize.min,            children: [              const Icon(Icons.star, color: Color(0xFFFDD000), size: 20),              const SizedBox(width: 4),              Text('$score', style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),            ],          ),        ],      ),    );  }}// ============================================================================// BATTLE RESULT SCREEN// ============================================================================class BattleResultScreen extends StatelessWidget {  final String category;  final String difficulty;  final String gameCode;  final int myScore;  final int opponentScore;  final String myName;  final String opponentName;  final String myAvatar;  final String opponentAvatar;  final int totalQuestions;  final bool didIWin;  final Map<String, dynamic>? badgeAwarded; // ‚úÖ NEW  const BattleResultScreen({    super.key,    required this.category,    required this.difficulty,    required this.gameCode,    required this.myScore,    required this.opponentScore,    required this.myName,    required this.opponentName,    required this.myAvatar,    required this.opponentAvatar,    required this.totalQuestions,    required this.didIWin,    this.badgeAwarded, // ‚úÖ NEW  });  Color _getDifficultyColor() {    switch (difficulty.toUpperCase()) {      case "EASY":        return const Color(0xFF1D9358);      case "AVERAGE":        return const Color(0xFF046EB8);      case "DIFFICULT":        return const Color(0xFFBD442E);      default:        return const Color(0xFF1D9358);    }  }  @override  Widget build(BuildContext context) {    final color = _getDifficultyColor();    return Scaffold(      body: Center(        child: SingleChildScrollView(          child: Padding(            padding: const EdgeInsets.all(40),            child: Column(              mainAxisAlignment: MainAxisAlignment.center,              children: [                // Victory/Defeat                Text(                  didIWin ? 'VICTORY!' : 'DEFEAT',                  style: TextStyle(                    fontSize: 70,                    fontWeight: FontWeight.bold,                    color: didIWin ? const Color(0xFFFDD000) : Colors.grey,                    fontFamily: 'Poppins',                  ),                ),                const SizedBox(height: 20),                // ‚úÖ Badge Progress Display (only for winner)                if (didIWin && badgeAwarded != null) ...[                  _buildBadgeProgress(color),                  const SizedBox(height: 20),                ],                const SizedBox(height: 20),                // Score display                Row(                  mainAxisAlignment: MainAxisAlignment.center,                  children: [                    _buildPlayerResult(myName, myAvatar, myScore),                    Padding(                      padding: const EdgeInsets.symmetric(horizontal: 40),                      child: Text(                        '$myScore : $opponentScore',                        style: const TextStyle(fontSize: 80, fontWeight: FontWeight.bold),                      ),                    ),                    _buildPlayerResult(opponentName, opponentAvatar, opponentScore),                  ],                ),                const SizedBox(height: 30),                Text('Questions: $totalQuestions of $totalQuestions', style: const TextStyle(fontSize: 16)),                const SizedBox(height: 40),                // Buttons                Row(                  mainAxisAlignment: MainAxisAlignment.center,                  children: [                    OutlinedButton(                      onPressed: () async {                        try {                          await FlameAudio.play('click1.wav');                        } catch (e) {                          debugPrint('Click sound not found: $e');                        }                        Navigator.of(context).pop();                      },                      style: OutlinedButton.styleFrom(                        padding: const EdgeInsets.symmetric(horizontal: 30, vertical: 14),                        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(30)),                      ),                      child: const Text('EXIT', style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),                    ),                    const SizedBox(width: 20),                    ElevatedButton(                      onPressed: () async {                        try {                          await FlameAudio.play('click1.wav');                        } catch (e) {                          debugPrint('Click sound not found: $e');                        }                        Navigator.of(context).pop();                      },                      style: ElevatedButton.styleFrom(                        backgroundColor: const Color(0xFF1D9358),                        padding: const EdgeInsets.symmetric(horizontal: 30, vertical: 14),                        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(30)),                      ),                      child: const Text(                        'PLAY AGAIN',                        style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold, color: Colors.white),                      ),                    ),                  ],                ),              ],            ),          ),        ),      ),    );  }  // ‚úÖ Badge progress widget  // ‚úÖ Simple badge earned display - Shows for ANY win (1/3, 2/3, or 3/3)  Widget _buildBadgeProgress(Color color) {    final badgeUnlocked = badgeAwarded!['badge_unlocked'] ?? false;    final badgeNumber = badgeAwarded!['badge_number'];    final difficultyName = badgeAwarded!['difficulty'];    return Container(      padding: const EdgeInsets.all(24),      decoration: BoxDecoration(        gradient: LinearGradient(          colors: [color.withValues(alpha:0.2), color.withValues(alpha:0.05)],          begin: Alignment.topLeft,          end: Alignment.bottomRight,        ),        borderRadius: BorderRadius.circular(20),        border: Border.all(color: color, width: 3),      ),      child: Column(        children: [          Icon(            badgeUnlocked ? Icons.emoji_events : Icons.military_tech,            color: badgeUnlocked ? const Color(0xFFFDD000) : color,            size: 60,          ),          const SizedBox(height: 12),          Text(            badgeUnlocked ? 'BADGE #$badgeNumber UNLOCKED!' : 'BADGE EARNED!',            style: TextStyle(              fontSize: 24,              fontWeight: FontWeight.bold,              color: color,              fontFamily: 'Poppins',            ),          ),          const SizedBox(height: 8),          Container(            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),            decoration: BoxDecoration(              color: color,              borderRadius: BorderRadius.circular(20),            ),            child: Text(              difficultyName.toUpperCase(),              style: const TextStyle(                fontSize: 14,                fontWeight: FontWeight.bold,                color: Colors.white,                fontFamily: 'Poppins',              ),            ),          ),          const SizedBox(height: 12),          Container(            padding: const EdgeInsets.all(12),            decoration: BoxDecoration(              color: Colors.white,              borderRadius: BorderRadius.circular(12),              border: Border.all(color: Colors.grey.shade300),            ),            child: Row(              mainAxisSize: MainAxisSize.min,              children: [                Icon(Icons.card_giftcard, color: color, size: 20),                const SizedBox(width: 8),                Flexible(                  child: Text(                    badgeUnlocked                        ? 'Visit Badges screen to claim!'                        : 'Keep winning to unlock badges!',                    style: const TextStyle(                      fontSize: 14,                      fontWeight: FontWeight.w600,                      color: Colors.black87,                    ),                    textAlign: TextAlign.center,                  ),                ),              ],            ),          ),        ],      ),    );  }  Widget _buildPlayerResult(String name, String avatar, int score) {    return Column(      children: [        CircleAvatar(radius: 60, backgroundImage: AssetImage(avatar)),        const SizedBox(height: 12),        Text(name, style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),        const SizedBox(height: 8),        Row(          mainAxisSize: MainAxisSize.min,          children: [            const Icon(Icons.star, color: Color(0xFFFDD000), size: 24),            const SizedBox(width: 6),            Text('$score', style: const TextStyle(fontSize: 24, fontWeight: FontWeight.bold)),          ],        ),      ],    );  }}